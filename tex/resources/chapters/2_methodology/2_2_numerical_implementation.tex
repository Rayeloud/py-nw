Different numerical strategies can be employed for phase-field modeling \cite{pfhub}. Here is a brief overview of different spatial discretization methods used in phase-field modeling:
\begin{itemize}
    \item Finite difference method
    \item Finite element method
    \item Finite volume method
    \item Fourier spectral method
\end{itemize}
Each methods has its own strength and weaknesses. In this study, the Fourier spectral method is used to solve the phase-field model considered. This method is fairly simple to implement and offer a high spatial error convergence rate. However, due to the mathematical properties of the Fourier transform, the method is limited to periodic boundary conditions and to the use of regular grids for spatial discretization. Thus, certain strategies are employed to overcome these limitations, especially the use of voxelization to represent any arbitrary shape in a regular grid.
\subsection{Fourier spectral method}
    Recall \autoref{eq:2-ch}, expressed as,
    \begin{equation}
        \frac{\partial c}{\partial t} = \nabla \cdot \left( M \nabla \mu \right)
    \end{equation}
    The solution to this equation with the Fourier spectral method starts by taking the forward Fourier transform of both sides of the equation.
    \begin{align}
        \frac{\partial \hat{c}}{\partial t} &= \Bigl\{\nabla \cdot ( M(c) \nabla \mu ) \Bigl\}_k\\
        \implies \frac{\partial \hat{c}}{\partial t} &= j\mathbf{k} \cdot \Bigl\{ M(c) \left[j\mathbf{k} \cdot \right(\hat{g(c)} + \kappa k^2 \hat{c}\left)\right]_r \Bigl\}_k
    \end{align}
    where $\hat{c}$ is the Fourier transform of $c$, $\{\cdot\}_k$ denotes the Forward Fourier transform of the expression inside the brackets, $\left[\cdot\right]_r$  denotes the Inverse Fourier transform of the expression in the brackets, $j$ is the pure imaginary number, $\mathbf{k}$ and $k$ are the wave vector and the wave vector magnitude respectively.\\
    Thus the problem simplifies to solving a system of ODEs in the Fourier reciprocal space.
\subsection{Time marching scheme}
    A time marching scheme is now needed to solve the system of ODEs in the Fourier reciprocal space. The simplest method is the Forward Euler method which is a first-order accurate method.
    \begin{equation}
        \hat{c}^{n+1} = \hat{c}^n + \Delta t j\mathbf{k} \cdot \Bigl\{ M(c) \left[j\mathbf{k} \cdot \left(\hat{g(c^n)} + \kappa k^2 \hat{c}^n\right)\right]_r \Bigl\}_k
    \end{equation}
    where $\Delta t$ is the time step and $n$ is the time step index.
    Unfortunately, the Forward Euler method is conditionally stable and suffer from a severe time step constraint. Indeed, by performing a Von-Neumann analysis on the above scheme, the time constraint can be derived.
    \subsubsection{Von-Neumann analysis}
    The model is most limited when the mobility function is at its maximum $\texttt{max}(M(c)) = M_0$
    \begin{align*}
        \hat{c}^{n+1} &= \hat{c}^n + \Delta t j\mathbf{k} \cdot \Bigl\{ M_0 \left[j\mathbf{k} \cdot \right(\hat{g(c^n)} + \kappa k^2 \hat{c}^n\left)\right]_r \Bigl\}_k\\
        &= \hat{c}^n - \Delta t M_0 k^2 \left(\hat{g(c^n)} + \kappa k^2 \hat{c}^n \right)
    \end{align*}
    Considering the most limiting factor i.e. the fourth order term, the derivative of the bulk free energy density in the Fourier reciprocal space is considered negligible. Thus, one writes,
    \begin{equation*}
        \hat{c}^{n+1} = \left(1 - \Delta t M_0 \kappa k^4 \right) \hat{c}^n
    \end{equation*}
    This finally leads to the amplification factor,
    \begin{align*}
        |\lambda| = |1 - \Delta t M_0 \kappa k^4| &\leq 1\\
        \implies \Delta t M_0 \kappa k^4 &\leq 1
    \end{align*}
    Which leads to the following Courant Friedrich Lewy (CFL) condition,
    \begin{equation}\label{eq:2-cfl}
        \Delta t = \texttt{CFL} \frac{1}{M_0 \kappa k^4} = \texttt{CFL} \frac{dx^4}{M_0 \kappa}
    \end{equation}
    \subsubsection{Semi-implicit treatment}
    To circumvent this constraint, a semi-implicit treatment inspired by Zhu et al.\ \cite{ZhuChenShenTikare1999} is performed by splitting the mobility into two parts i.e.\ $M(c) \rightarrow (M(c) - \alpha), \alpha$, with $\alpha$ the stabilization factor. This leads to a semi-implicit treatment of the fourth order term.
    The scheme is then written as,
    \begin{equation}
        \begin{aligned}
            \frac{\hat{c}^{n+1}-\hat{c}^n}{\Delta t} = j\mathbf{k} \cdot \Bigl\{ (M(c) - \alpha) \left[j\mathbf{k} \cdot \left(\hat{g(c^n)} + \kappa k^2 \hat{c}^n\right)\right]_r \Bigl\}_k\\
            + \alpha j\mathbf{k} \cdot \left[j\mathbf{k} \cdot \left(\hat{g(c^n)} + \kappa k^2 \hat{c}^{n+1}\right)\right]
        \end{aligned}
    \end{equation}
    Expanding the above equation and isolating both $\hat{c}^{n+1}$ and $\hat{c}^n$ leads to the following semi-implicit Fourier Spectral scheme,
    \begin{equation}
        \begin{aligned}
            \hat{c}^{n+1} = \hat{c}^n + \frac{\Delta t j\mathbf{k} \cdot \Bigl\{ M(c) \left[j\mathbf{k} \cdot \left(\hat{g(c^n)} + \kappa k^2 \hat{c}^n\right)\right]_r \Bigl\}_k}{1 + \alpha \Delta t \kappa k^4}
        \end{aligned}
    \end{equation}
    Zhu et al.\ \cite{ZhuChenShenTikare1999} showed that choosing $\alpha = \frac{1}{2} (\texttt{max}(M(c)) + \texttt{min}(M(c)))$ alleviates the time step constraint of the explicit scheme.

\subsection{Diffuse filtering scheme}
    In addition to the semi-implicit treatment, a diffuse filtering scheme inspired by Sinhababu et al.\ \cite{SinhababuBhattacharya2022} is employed to further stabilize the scheme. Indeed, the Fourier spectral method is know to suffer from the Gibbs phenomenon\ \cite{vSircaHorvat2012}--\cite{Fornberg1996} which leads to numerical oscillations near interfaces. Since the considered problems are interfacial physics problems, numerical oscillations are detrimental to the solution. Thus a dealiasing method is employed to filter out high frequency Fourier modes.
    The diffuse filtering scheme filters out Fourier modes of frequency higher than $|k| \geq \frac{\sqrt{2}N}{3}$ with $N$ the lowest dimension of the grid. Following the notation in \cite{SinhababuBhattacharya2022}, it is defined as follows,
    \begin{equation}
        \mathcal{W}(\mathbf{k}) = \frac{1}{2}\left[1+\tanh{\left(\frac{\frac{\sqrt{2}N}{3} - \sqrt{k_x^2 + k_y^2 + k_z^2}}{\epsilon}\right)}\right]
    \end{equation}
    with $\epsilon = 3\times\texttt{max}(\Delta k_x, \Delta k_y, \Delta k_z)$, with $\Delta k_i$ the grid spacing in the $i$ direction in the Fourier reciprocal space.\\
    The filtered Fourier transform of an arbitrary function now writes $\{f\}_k\rightarrow \hat{f} \cdot \mathcal{W}(\mathbf{k})$. The filtered reciprocal space is represented in \autoref{chap2:2-filtered-fourier}.
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{chap2/2-diffuse-filter}
        \caption{Filtered Fourier reciprocal space.}
        \label{chap2:2-filtered-fourier}
    \end{figure}
    \subsection{Implementation}
    The numerical scheme implementation is detailed in \autoref{fig:2-flowchart} and is inspired from \cite{Roy2021}. The implementation is done in \texttt{Python3.8} using the \texttt{PyTorch} library\ \cite{Ansel2024}.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{chap2/2-implementation.png}
        \caption{Flowchart of the numerical scheme implementation.}
        \label{fig:2-flowchart}
    \end{figure}
    \texttt{PyTorch} is a high-performance deep learning library which offers automatic differentiation and and more importantly GPU acceleration which is crucial for solving phase-field problems. The Fast Fourier Transforms (resp. Inverse Fast Fourier Transforms) are computed using \texttt{torch.fft.rfftn} (resp. \texttt{torch.fft.irfftn}) since the phase-field is real valued. In addition, the \texttt{gmsh} python library is used to generate geometries, i.e.\ the initial configuration of the phase field which are then voxelize to fit the required regular grid. The details on voxelization are provided in \autoref{chap:2_4-nanowire}. Finally, the visualisation is perfomed using \texttt{Paraview}.\\
    Numerical experiments on the implemented model are now performed on a \texttt{MacBook Pro 16'' M1 Max} with $64\,\text{GB}$ of RAM.
